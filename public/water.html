<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Realistic 2D Beer Glass Fluid Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222;
      font-family: Arial, sans-serif;
      color: #fff;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 10px;
    }
    #ui label {
      display: block;
      margin-bottom: 10px;
    }
    #ui input[type="range"],
    #ui input[type="number"] {
      width: 200px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>
      <label for="waterLevel">Water Level:</label>
      <input id="waterLevel" type="range" min="0.2" max="0.8" step="0.01" value="0.5" />
    </div>
    <div>
      <label for="bubbleCount">Bubbles:</label>
      <input id="bubbleCount" type="number" value="30" min="0" max="100" style="width: 60px;" />
    </div>
  </div>

  <!-- Include p5.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
  <script>
    // Global Variables
    let waterLevelSlider, bubbleCountInput;
    let waterLevel = 0.5; // Initial water level (0.2 to 0.8)
    let bubbles = [];
    let bubbleCount = 30; // Initial number of bubbles

    // Bubble Class
    class Bubble {
      constructor(x, y, size, speed, swayAmplitude, swayFrequency) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.speed = speed;
        this.swayAmplitude = swayAmplitude;
        this.swayFrequency = swayFrequency;
        this.offset = random(1000); // Unique offset for Perlin noise
      }

      update() {
        this.y -= this.speed;
        // Update x position based on Perlin noise for natural sway
        this.x += sin(this.y * this.swayFrequency + this.offset) * this.swayAmplitude;

        // Reset bubble to bottom if it reaches the top
        if (this.y < waterLevel * height - 150) { // Adjust based on water level
          this.reset();
        }
      }

      reset() {
        this.x = random(width * 0.3, width * 0.7); // Within glass bounds
        this.y = height * 0.75; // Bottom of the glass
        this.size = random(5, 15);
        this.speed = random(1, 3);
        this.swayAmplitude = random(0.5, 1.5);
        this.swayFrequency = random(0.05, 0.15);
        this.offset = random(1000);
      }

      display() {
        noStroke();
        fill(255, 200);
        ellipse(this.x, this.y, this.size);
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      angleMode(DEGREES);
      // Initialize UI Elements
      waterLevelSlider = select('#waterLevel');
      bubbleCountInput = select('#bubbleCount');

      // Set up initial bubbles
      for (let i = 0; i < bubbleCount; i++) {
        let x = random(width * 0.3, width * 0.7); // Within glass bounds
        let y = height * 0.75; // Bottom of the glass
        let size = random(5, 15);
        let speed = random(1, 3);
        let swayAmplitude = random(0.5, 1.5);
        let swayFrequency = random(0.05, 0.15);
        bubbles.push(new Bubble(x, y, size, speed, swayAmplitude, swayFrequency));
      }
    }

    function draw() {
      background('#222');
      drawGlass();
      drawFluid();
      handleBubbles();
    }

    // Function to draw the glass
    function drawGlass() {
      push();
      translate(width / 2, height / 2 + 100);
      noFill();
      stroke(200);
      strokeWeight(4);
      beginShape();
      // Top ellipse
      ellipse(0, 0, 300, 50);
      // Left side
      line(-150, 25, -150, 300);
      // Right side
      line(150, 25, 150, 300);
      // Bottom ellipse
      ellipse(0, 300, 300, 50);
      endShape();
      pop();
    }

    // Function to draw the fluid with waves
    function drawFluid() {
      push();
      translate(width / 2, height / 2 + 100);
      noStroke();
      fill('#f5c518'); // Beer-like color

      // Calculate current water level in pixels
      let currentLevel = waterLevel * height * 0.6; // 0.6 scales the water to fit within the glass

      // Create waves using Perlin noise
      beginShape();
      vertex(-150, currentLevel);
      for (let x = -150; x <= 150; x += 10) {
        let y = currentLevel + noise((x + frameCount * 0.02) * 0.5) * 10 - 5;
        vertex(x, y);
      }
      vertex(150, currentLevel);
      vertex(150, 300);
      vertex(-150, 300);
      endShape(CLOSE);
      pop();
    }

    // Function to handle bubbles
    function handleBubbles() {
      for (let bubble of bubbles) {
        bubble.update();
        bubble.display();
      }
    }

    // Function to create a new bubble
    function makeBubble() {
      let x = random(width * 0.3, width * 0.7); // Within glass bounds
      let y = height * 0.75; // Bottom of the glass
      let size = random(5, 15);
      let speed = random(1, 3);
      let swayAmplitude = random(0.5, 1.5);
      let swayFrequency = random(0.05, 0.15);
      return new Bubble(x, y, size, speed, swayAmplitude, swayFrequency);
    }

    // Event Listeners for UI Controls
    function mousePressed() {
      // Optional: Add interaction, e.g., create bubbles on click
      // let bubble = makeBubble();
      // bubbles.push(bubble);
    }

    // Update bubbles when bubble count changes
    bubbleCountInput.input(() => {
      let desiredCount = parseInt(bubbleCountInput.value());
      if (desiredCount > bubbles.length) {
        let toAdd = desiredCount - bubbles.length;
        for (let i = 0; i < toAdd; i++) {
          bubbles.push(makeBubble());
        }
      } else if (desiredCount < bubbles.length) {
        bubbles.splice(desiredCount, bubbles.length - desiredCount);
      }
      bubbleCount = desiredCount;
    });

    // Update water level when slider changes
    waterLevelSlider.input(() => {
      let val = parseFloat(waterLevelSlider.value());
      waterLevel = val;
      // Reset bubbles that are out of the new water level
      for (let bubble of bubbles) {
        if (bubble.y > waterLevel * height * 0.6 + height / 2) {
          bubble.reset();
        }
      }
    });

    // Handle window resize
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      // Optionally, reposition elements based on new size
    }
    windowResized();
  </script>
</body>
</html>
